# Headline

// docsify serve docs
https://giantaxewhy.github.io/docs/

<!--
https://github.com/GiantAxeWhy/MVVM-why.git

http://81.70.248.176:12306/

      > An awesome project.
      > 在京东的半年工作中，负责前端项目的搭建，业务模块的实现联调等工作，主要技术栈使用的 vue。半年过程中提交了两片专利，一篇已经过审，一篇审查中，分别是 基于大数据的虚拟列表的不定高实现，与基于大数据的高性能深拷贝在项目中的应用,在快速了解业务以及实现的过程中，发现了现存的一些问题，包括有外包团队较大，人员流动频繁，导致项目代码上手困难，项目样式不统一，不同组件多次封装，做重复性工作的现象，因此提出了封装自己的组件库，帮助团队成员更快更好上手代码，并且统一样式，例如之前的15名外包，现在剩余十名，但项目流转依旧正常。在为前端赋能提效的同时，为了减少产品与业务，产品与前端之间信息传递的低效，提出了低代码平台配合组件库的代码平台，实现了前端提效与赋能产品。
      同时业余时间实现了自己的技术博客搭建采用 vue+express+mysql 的技术栈，同时前段时间自己实现了一个 min-vue,基本自主实现了一些核心基础功能.



      Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统。

      > 在虚拟滚动实现的过程中，封装了一个小组件
      > 1、计算当前可视区域的起始数据索引（startIndex）
      > 2、计算当前可视区域的末尾数据索引（endIndex）
      > 3、可视区域的数据，渲染到可视区域
      > 4、计算起始数据索引 在整个列表数据索引中的偏移位置（startOffset）并且设置到列表中 因此整个可视区域的渲染结构如下
      > 1）假定可视区域高度固定，称之为 screenHeight
      > 2）假定列表每项高度固定，称之为 itemSize
      > 3）假定列表数据称之为 listData
      > 4）假定当前滚动位置称之为 scrollTop
      > 由此可得出计算关系 1、列表总高度 listHeight = listData.length \* itemSize
      > 2、可显示的列表项数 visibleCount = Math.ceil(screenHeight / itemSize)
      > 3、数据的起始索引 startIndex = Math.floor(scrollTop / itemSize)
      > 4、数据的结束索引 endIndex = startIndex + visibleCount
      > 5、列表显示数据为 visibleData = listData.slice(startIndex,endIndex)
      > 当滚动后，由于渲染区域相对于可视区域已经发生了偏移，此时我需要获取一个偏移量 startOffset，通过样式控制将渲染区域偏移至可视区域中。
       偏移量 startOffset = scrollTop - (scrollTop % itemSize);
      > 扩展 当需要渲染的 item 高度不固定时
      以预估高度先行渲染，然后获取真实高度并缓存。

      定义组件属性 estimatedItemSize,用于接收预估高度
      并在初始时根据 estimatedItemSize 对 positions 进行初始化。

      由于列表项高度不定，并且我们维护了 positions，用于记录每一项的位置，而列表高度实际就等于列表中最后一项的底部距离列表顶部的位置。
      由于需要在渲染完成后，获取列表每项的位置信息并缓存，所以使用钩子函数 updated 来实现：
      滚动后获取列表开始索引的方法修改为通过缓存获取：

数组：连续
连续空间存储是数组的特点，下图是数组在内存中的存储示意图。

固定长度

因为数组的空间是连续的，这就意味着在内存中会有一整块空间来存放数组，如果不是固定长度，那么内存中位于数组之后的区域会没办法分配，内存不知道数组还要不要继续存放，要使用多长的空间。长度固定，就界定了数组使用内存的界限，数组之外的空间可以分配给别人使用。

相同数据类型
因为数组的长度是固定的，如果不是相同数据类型，一会存一个 int ，一会存一个 String ，两种不同长度的数据类型，不能保证各自存放几个，这样有悖固定长度的规定，所以也要是相同的数据类型。

我们看到 JSArray 是继承自 JSObject，也就是说，数组是一个特殊的对象。

那这就好解释为什么 JS 的数组可以存放不同的数据类型，它是个对象嘛，内部也是 key-value 的存储形式。

可以看到，底层就是个 Map ，key 为 0，1，2，3 这种索引，value 就是数组的元素。

数组的 index 其实是字符串。

# fast ：

快速的后备存储结构是 FixedArray ，并且数组长度 <= elements.length();

快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，那来看下源码中是怎么扩容和收缩的。
FixedArray 是 V8 实现的一个类似于数组的类，它表示一段固定长度的连续的内存。
也就是，扩容后的新容量 = 旧容量的 1.5 倍 + 16

扩容后会将数组拷贝到新的内存空间中
收缩：
可以看出收缩数组的判断是： 如果容量 >= length 的 2 倍 + 16，则进行收缩容量调整，否则用 holes 对象（什么事 holes 对象？下面来解释）填充未被初始化的位置。

# slow ：

慢数组是一种哈希表的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 HashTable，其效率会比快数组低。

缓慢的后备存储结构是一个以数字为键的 HashTable 。

HashTable，维基百科中解释的很好：

散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

源码注释中的 fast 和 slow，只是简单的解释了一下，对应的是快数组和慢数组，下面来具体的看一下两种形式是如何实现的。

# 快转慢

也就是说，当对数组赋值时使用远超当前数组的容量+ 1024 时（这样出现了大于等于 1024 个空洞，这时候要对数组分配大量空间则将可能造成存储空间的浪费，为了空间的优化，会转化为慢数组。
代码实锤：
let a = [1, 2]
a[1030] = 1;
复制代码数组中只有三个元素，但是却在 1030 的位置存放了一个值，那么中间会有多于 1024 个空洞，这时就会变为慢数组。

# 慢转快

慢 -> 快
处于哈希表实现的数组，在每次空间增长时， V8 的启发式算法会检查其空间占用量， 若其空洞元素减少到一定程度，则会将其转化为快数组模式。

# 优略

快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。 慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。

# 高性能深拷贝

那么是否可以有一种实现的做法，只有当属性修改以后才对这部分数据做深拷贝，又能解决 JSON.parse(JSON.stringify(a)) 的局限呢。这种做法当然是存在的，唯一的点是我们如何知道用户修改了什么属性？
答案是 Proxy，通过拦截 set 和 get 就能达到我们想要的，当然 Object.defineProperty() 也可以。其实 Immer 这个库就是用了这种做法来生成不可变对象的，接下来就让我们来试着通过 Proxy 来实现高性能版的深拷贝。

# 项目经验

            我做这个开源是为了解决什么问题?/这个项目的最终目的是什么
            目前已有的解决方案有哪些?
            我怎么做, 才能做的比已有的方案更好?
            我如何才能让我的项目持续发展下去, 而不是过眼云烟?/掌控项目进度

在解答了以上 4 个问题之后, 我们做开源项目会更有目标和框架感, 也更能明确自己能得到什么:

            独一无二的解决方案
            对该领域有更深度的研究和了解
            对未来职业发展更有谈资
            收获了更多技术方案和开源小伙伴
            通过项目价值体现个人价值和某一领域影响力
            收获money, 流量, 企业offer

不要过度的追求结果, 我们在做有价值的开源项目的过程中, 自然会让自己变得更有价值.

1.目标规划期
首先在明确了为什么要做这个项目之后, 我们需要对自己的开源项目有个清晰完整的规划路线. 比如 1.0 版本需要做哪些功能, 哪些功能是高优先级一定要完成的,哪些是不紧急的, 可以后期在完成. 所以我们要充分利用好四象限法则.
其次就是明确的功能拆分, 需求池管理, 学会过滤需求, 而不是一股脑的全盘接收, 因为有时候用户提的需求他自己也不知道, 所以需要评审.

有了以上目标规划和管理法则, 我们就能有一个清晰而高效的目标规划了.

2. 项目基建期
   项目基建期主要是项目的雏形, 这个阶段一定是项目负责人搭建, 需要对项目的整体技术选型, 架构, 解决方案设计等有完整的思路和落地方案. 这样才能为以后团队开发, 迭代和项目优化打下基础, 否则最终会乱成一片. H5-Dooring 在项目初期也是按照这个思路走的, 我先把项目完整流程设计出来, 并在 github 上开源, 后面才能找到一批直观且感兴趣的朋友来维护和优化.

3.团队组建期
团队组建也是非常关键的环节. 首先创始人需要具备一下特质:

具备一定的技术实力(能独立做出解决方案, 把控整个项目)
对项目有一定研究深度并且有明确的目标规划
绝对的执行力, 发挥领头羊作用
格局放大, 接受能力比你强或者比你弱的朋友, 发挥其长处
对项目有坚定的信念
谦虚 + 追求极致
相互学习和共同成长的态度和团队相处

只有具备以上 3 点以上, 才能打造高效且有凝聚力的团

4.团队协作/磨合期
团队协作/磨合也就是我们在任务分工时, 相互之间做的一些交流, 沟通等.
我们需要让每个共建者明确我们共同的目标, 以及各自的分工. 这个阶段往往也是考核团队的最佳时期, 我们可以发现团队不同的成员擅长什么,可以胜任哪些工作, 哪些任务可以让他通过项目来获得提高和成长.
所以定期交流必不可少

5.版本迭代和复盘期
每个阶段我们的项目都需要有一次复盘, 反思. 所以做完是第一步, 如何让项目做的更好, 才是项目长期发展的关键. 团队中每个人都可以提建议, 提出自己的看法和发展方向, 不断的头脑风暴, 把项目做到极致. 当然其中需要把控, 取舍. 就好像 PDCA 循环. -->
